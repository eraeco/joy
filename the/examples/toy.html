<!-- script src="https://cdn.jsdelivr.net/npm/acorn@8.14.1/dist/acorn.min.js"></script -->
<script src="/acorn.js"></script>
<script class="SecureRender" src="../content.js">
the.start = the.start || (async () => {

  setTimeout(() => {/*
*/var code = `
import a from 'module';
import { b } from 'module';
import { c, d } from 'module';
import * as e from 'module';
import f, { g, h as i } from 'module';

var x = 10;
let y = 'Hello World';
const z = true;

x = 11;
x = 12, x = 13;

function add(a, b) {
  return a + b;
}
function multiply(a, b = 2) {
    return a * b;
}
var sq = function (n) {
  return n * n;
}
let square = n => n * n;
const divide = (a, b) => { return a / b };
divide(1,2);

(function(){
  var a = 1;
})();

async function get(url) { await fetch(url) }
var aget = async function(url){ await fetch(url) }
let agat = async (a) => { await fetch(url) }

function* gen(id) { yield id + 1 }
var genv = function*(id){ yield id + 1 }
async function* agen(id){ yield id + 1 }
var agenv = async function*(id){ yield id + 1 }
var person = { name: 'Alice', age: 25, eye: {color: 'blue'} };
const { name } = person;
const { age, gender = 'Female' } = person;

const numbers = [1, 2, 3];
const [first, second, third] = numbers;

if(y > 5) y = 0;

if(x > 5){
  x = 5;
} else if (x < 0){
  x = 0
} else {
  x = 2.5;
}
`;/*

var b = {c: "Hello", d: "World"};
const somethin = b?.c;

// Switch statement
TODO: Need to fix this
switch (y) {
    case 'Hello':
        console.log('Greeting detected');
        break;
    case 'Goodbye':
        console.log('Farewell detected');
        break;
    default:
        console.log('Unknown message');
}

// For loop
for (let i = 0; i < 5; i++) {
    console.log('For loop iteration:', i);
}

// While loop
let count = 0;
while (count < 3) {
    console.log('While loop count:', count);
    count++;
}

// // Do-while loop
do {
    console.log('Do-while loop count:', count);
    count--;
} while (count > 0);

// For...in loop (enumerate object properties)
for (const key in person) {
    if (person.hasOwnProperty(key)) {
        console.log('Property:', key, 'Value:', person[key]);
    }
}

// For...of loop (iterate over iterable objects)
//TODO: Need to fix this
for (const num of numbers) {
    console.log('Number:', num);
}

// Exception Handling

// Try-catch-finally block
try {
  console.log('Try block executed');
  throw new Error('An error occurred');
} catch (error) {
  console.error('Caught error:', error.message);
} finally {
  console.log('Finally block executed');
}

// Rest and Spread Operators

// Rest parameters in a function
TODO: Need to fix this
function sumAll(...args) {
    return args.reduce((sum, current) => sum + current, 0);
}

// Spread syntax in array literals
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5];

// Spread syntax in object literals
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 };

// Classes and Inheritance

// Class declaration
TODO: Need to fix this
class Animal {
    constructor(name) {
        console.log('Animal constructor called');
    }
    speak() {
        console.log('Makes a noise.');
    }
}

// Subclass with inheritance
class Dog extends Animal {
    speak() {
        console.log(this.name + ' barks.');
    }
}

const dog = new Dog('Rex');
dog.speak();

// Miscellaneous Features

// Regular expressions
const regex = /ab+c/;

// New operator with built-in types
const date = new Date();

// Using Math object
const randomNum = Math.random();

// Using JSON methods
const jsonString = JSON.stringify(person);
const jsonObject = JSON.parse(jsonString);

// Using setTimeout (asynchronous code)
setTimeout(function () {
    console.log('Timeout executed');
}, 1000);

// Working with Promises
const promise = new Promise(function (resolve, reject) {
    setTimeout(() => resolve('Promise resolved'), 500);
});
promise.then(result => console.log(result));

// Using Map and Set
TODO: Need to fix this
const map = new Map();
map.set('key', 'value');
const set = new Set([1, 2, 3]);

//Symbol type
const sym = Symbol('unique');

// BigInt type
const bigIntNumber = 12345678901234567890n;

// Bitwise operators
const bitwiseResult = 5 & 1;

// Typeof operator
console.log(typeof x); // 'number'

// Delete operator
const obj3 = { prop: 'value' };
delete obj3.prop;

// Void operator
void function () {
    console.log('Void operator used');
}();

// Instanceof operator
console.log(dog instanceof Dog); // true

// In operator
console.log('name' in dog); // true

// Conditional (ternary) operator
const max = x > y.length ? x : y.length;

// Logical operators
const logicalAnd = x > 0 && y.length > 0;
const logicalOr = x < 0 || y.length > 0;
const logicalNot = !z;

// Assignment operators
x += 5;
x -= 2;
x *= 3;
x /= 2;
x %= 3;
x **= 2;

// Unary operators
const negation = -x;
const positive = +y.length;

// Comparison operators
const isEqual = x == y.length;
const isIdentical = x === y.length;
const isNotEqual = x != y.length;
const isNotIdentical = x !== y.length;
const isGreater = x > y.length;
const isLess = x < y.length;
const isGreaterOrEqual = x >= y.length;
const isLessOrEqual = x <= y.length;

// Comma operator
let a, b, c;
a = (b = 1, c = 2);

// Function hoisting
hoistedFunction();
function hoistedFunction() {
    console.log('Function hoisting example');
}

// Variable hoisting (var only)
console.log(hoistedVar); // undefined
var hoistedVar = 'Hoisted variable';

// Using 'this' keyword
const obj4 = {
    name: 'Object',
    getName: function () {
        return this.name;
    }
};
console.log(obj4.getName());

// Closure example
function outerFunction(outerVariable) {
    return function innerFunction(innerVariable) {
        console.log('Outer Variable:', outerVariable);
        console.log('Inner Variable:', innerVariable);
    };
}
const newFunction = outerFunction('outside');
newFunction('inside');

// Immediately resolved Promise
Promise.resolve('Immediate value').then(value => console.log(value));

// Chained Promises
Promise.resolve(1)
    .then(value => value + 1)
    .then(value => value + 1)
    .then(value => console.log('Final value:', value));

// Using 'arguments' object in a function
function argumentsExample() {
    console.log('Arguments length:', arguments.length);
}
argumentsExample(1, 2, 3);

// Object methods: Object.keys, Object.values, Object.entries
console.log('Object keys:', Object.keys(person));
console.log('Object values:', Object.values(person));
console.log('Object entries:', Object.entries(person));

// Array methods: map, filter, reduce
const mappedNumbers = numbers.map(n => n * 2);
const filteredNumbers = numbers.filter(n => n > 1);
const reducedNumber = numbers.reduce((acc, n) => acc + n, 0);

// String methods
const upperCaseString = y.toUpperCase();
const replacedString = y.replace('H', 'J');

// Using 'new.target' inside a function
function ConstructorExample() {
    if (!new.target) {
        throw new Error('Must be called with new');
    }
    this.example = 'Example';
}
new ConstructorExample();

// Using eval (caution: can be dangerous)
const code = 'console.log("Evaluated code")';
eval(code);

// Regular expression methods
const testString = 'abc';
const testResult = /a/.test(testString);
const matchResult = testString.match(/a/);

// Labeled statements
outerLabel: for (let i = 0; i < 5; i++) {
    innerLabel: for (let j = 0; j < 5; j++) {
        if (j === 2) continue outerLabel; 
        if (i === 3) break innerLabel;
    }
}

// Using 'strict mode'
(function () {
    'use strict';
    // Strict mode code here
    // Variables must be declared
    let strictVar = 'Strict mode variable';
})();

// Using 'this' in different contexts
console.log(this); // In global scope, 'this' refers to global object

function globalThisExample() {
    console.log(this); // In non-strict mode, 'this' refers to global object
}
globalThisExample();

const objectWithMethod = {
    method: function () {
        console.log(a); // 'this' refers to objectWithMethod
    }
};
objectWithMethod.method();  

// Unary plus and minus operators
const numString = '123';
const numValue = +numString; // Converts string to number
const negValue = -numValue;

// Bitwise operators
const bitwiseAnd = 5 & 3; // 1
const bitwiseOr = 5 | 3;  // 7
const bitwiseXor = 5 ^ 3; // 6
const bitwiseNot = ~5;    // -6
const leftShift = 5 << 1; // 10
const rightShift = 5 >> 1; // 2
const unsignedRightShift = -5 >>> 1; // Large positive number

// Function with rest parameter and destructuring
function restDestructure({ a, b }, ...rest) {
    console.log('a:', a, 'b:', b, 'rest:', rest);
}
restDestructure({ a: 1, b: 2 }, 3, 4, 5);

// Accessor properties
const accessorExample = {
    _value: 0,
    get value() {
        return this._value;
    },
    set value(val) {
        this._value = val;
    }
};
accessorExample.value = 42;
console.log(accessorExample.value); // 42

// Function with default parameters
function defaultParams(a, b = 10) {
    return a + b;
}
console.log(defaultParams(5)); // 15

// Short-circuit evaluation
const shortCircuit = x > 0 && y.length > 0;
// Optional chaining (ECMAScript 2020)
const optionalChainingResult = obj && obj.nonExistentProp && obj.nonExistentProp.subProp;
// Nullish coalescing operator (ECMAScript 2020)
const nullishValue = null != null ? null : 'Default value';
// Numeric es (ECMAScript 2021)
const largeNumber = 1000000;
// End of code examples
(fn())(args);
obj[computedProperty]();
obj.method(c).chain().calls(b);
//--------------
// Variables
a = 0.1;
let x = 1;
const y = 2;
var z = 3;

// Data Types
let num = 42;
let str = "hello";
let bool = true;
let nul = null;
let und = undefined;
let sym = Symbol("id");
let obj = { a: 1 };
let arr = [1, 2, 3];
let big = 123n;

// Functions
function func() { return 1; }
let arrow = () => 2;

// Operators
let sum = 1 + 2;
let diff = 3 - 1;
let prod = 2 * 3;
let quot = 6 / 2;
let mod = 5 % 2;
let exp = 2 ** 3;

// Comparisons
let eq = 1 === 1;
let neq = 1 !== 2;
let gt = 2 > 1;
let lt = 1 < 2;
let gte = 2 >= 2;
let lte = 1 <= 1;

// Logical
let and = true && false;
let or = true || false;
let not = !true;

// Control Flow
if (true) { let a = 1; }
else { let b = 2; }

switch (x) {
  case 1: break;
  default: break;
}

for (let i = 0; i < 1; i++) {}
while (x > 0) { x--; }
do { z--; } while (z > 0);

// Arrays
arr.push(4);
arr.pop();
arr.map(x => x * 2);

// Objects
obj.b = 2;
delete obj.a;

// Classes
class MyClass {
  constructor() { this.x = 1; }
  method() { return this.x; }
}
let instance = new MyClass();

// Promises
let prom = new Promise((resolve) => resolve(1));

// Async/Await
async function asyncFunc() { return 1; }

// Template Literals
let temp = `x is ${x}`;

// Destructuring
let [a, b] = [1, 2];
let { c } = { c: 3 };

// Spread/Rest
let spread = [...arr];
let rest = (...args) => args;

// Try/Catch
try { throw new Error(); } catch (e) {}

// Ternary
let tern = true ? 1 : 0;
```*/;
    var ast = acorn.parse(code,{
      ecmaVersion: 2022, sourceType: 'module',
      onComment: function(){ }
    });

    render(ast);
  }, 1);

})();

/* ---- the Code from Phone TOY is below ------ */

/**
-[ ] fix do while to retain structure
-[ ] switch broke as well
-[ ] render ? for optional chaining
-[ ] else 
*/

function render(ast, stop) { // built by Natnael, Mars.
  if(!ast){ return }

  render.annotate(ast);
  console.log(ast.type||'', ast);

  if(ast.up){
    render.the({
      name: ast.up.$id,
      sort: stop || [0.1, ast.up.up.$id],
      fill: render.fill(ast.up)
    });
  }

  if(ast.left){ ast.left.up = ast; render(stop || ast.left) }
  if(ast.length){
    ast.forEach((sub, i) => {
      if (i > 0) {
        render.the({
          name: ast.$id+'-text-'+i,
          sort: stop || [0.1, ast.$id],
          fill: ast.text || ','
        });
      }
      sub.up = ast;
      render(stop || sub);
    });
  } else
  if(ast.text){
    render.the({
      name: ast.$id,
      sort: stop || [0.1, ast.up.$id],
    }).the({
      name: ast.$id + '-text',
      sort: stop || [0.1, ast.$id],
      fill: ast.text
    })
  }
  if(ast.right){ ast.right.up = ast; render(stop || ast.right) }
}

// Normalize the AST into a consistent LEFT-OPERATOR-RIGHT structure
render.annotate = function(ast){ ast = ast || '';
  ast.up = ast.up || '';
  ast.$id = ast.$id || render.id(ast);
  if(!ast.type){ return ast }

  switch (ast.type) {
    case 'Program':
      ast.left = {text:''};
      ast.right = ast.body;
      ast.right.text = ';';
      ast.right.right = {text: ';'};
      ast.fill = ast.left.fill = ast.right.fill = [];
      break;
    case 'SequenceExpression':
      ast.expressions.fill = [];
    case 'ExpressionStatement':
      ast.right = ast.expressions || ast.expression;
      ast.fill = [];
      break;

    case 'Literal':
    case 'Identifier':
      ast.text = ast.text || ast.op || ast.raw || ast.name;
      break;

    case 'ImportDeclaration':
      ast.right = ast.source;
      ast.text = ast.op = 'from';
      // ugly re-arrange:
      var tmp = ast.specifiers;
      tmp.left = {text: '{'}; tmp.right = {text: '}'};
      tmp = ast.left = {left: {text:''}, right: tmp};
      tmp.text = tmp.op = 'import';
      if('ImportDefaultSpecifier' == tmp.right[0].type
      || 'ImportNamespaceSpecifier' == tmp.right[0].type){
        tmp.right = [ast.specifiers[0], ast.specifiers.slice(1)];
        tmp.right[1].left = {text: '{'}; tmp.right[1].right = {text: '}'};
        if('ImportDefaultSpecifier' == tmp.right[0].type){ tmp.right[0] = tmp.right[0].local }
        if(0 == tmp.right[1].length){ tmp.right = tmp.right[0] }
      }
      break;
    case 'ImportNamespaceSpecifier':
      ast.left = {text: '*'};
      ast.text = ast.op = 'as';
      ast.right = ast.local;
      break;
    case 'ImportDefaultSpecifier':
    case 'ImportSpecifier':
      if(ast.imported.name !== ast.local.name){
        ast.left = ast.imported;
        ast.op = ast.text = 'as';
      }
      ast.right = ast.local;
      break;

    case 'VariableDeclaration':
      ast.op = ast.type;
      ast.left = {text: ast.kind, fill: []};
      ast.right = ast.declarations;
      ast.fill = ast.right.fill = [];
      break;
    case 'VariableDeclarator':
    case 'AssignmentPattern':
    case 'AssignmentExpression':
      ast.left = ast.id || ast.left;
      ast.text = operator = '=';
      ast.right = ast.init || ast.right;
      break;

    case 'BinaryExpression':
    case 'LogicalExpression':
      ast.op = ast.text = ast.operator;
      break;

    case 'ArrowFunctionExpression':
      ast.arrow = true;
      ast.op = ast.text = '=>';
      if(!ast.body.length){ ast.right = [ast.body] }
      ast.fill = render.fill(ast);
    case 'BlockStatement':
    case 'FunctionExpression':
    case 'FunctionDeclaration':
      ast.right = ast.right || (ast.body||'').body || ast.body;
      ast.left = ast.params || ast.left || {text:''};
      if(ast.params){
        ast.params.left = {text:'('};
        ast.params.right = {text:')'};
        if(ast.id){
          ast.left = {left: {text: 'function'}, op: ast.id.name, right: ast.params};
          ast.left.text = ast.left.op;
          if(ast.async){
            ast.left.left.left = {text: 'async'};
          }
          if(ast.generator){
            ast.left.left.right = {text: '*'};
          }
        } else {
          ast.left.left = {text: (ast.async?'async ':'')+(ast.arrow?'':'function')+(ast.generator?'*':'')+'('};
        }
        ast.right.left = {text:'{'};
        ast.right.text = ';';
        ast.right.right = {text:'}'};
      }
      ast.fill = ast.fill || [];
      break;
    case 'ReturnStatement':
      ast.text = 'return';
      ast.right = ast.argument;
      ast.fill = [];
      break;
    case 'CallExpression':
      ast.left = (ast.expression||'').callee || ast.callee;
      ast.right = (ast.expression||'').arguments || (ast.expression||'').argument || ast.arguments || ast.argument;
      ast.right.left = {text:'('};
      ast.right.right = {text:')'};
      break;

    case 'ObjectPattern':
    case 'ObjectExpression':
      ast.right = ast.properties;
      ast.right.left = {text: '{'};
      ast.right.right = {text: '}'};
      ast.fill = ast.right.fill = [];
      break;
    case 'Property':
      ast.left = ast.key;
      if(ast.shorthand){
        if(!ast.value.name){
          ast.left = ast.value;
          ast.fill = [];
        }
      } else {
        ast.op = ast.text = ':';
        ast.right = ast.value;
      }
      break;

    case 'ArrayPattern':
    case 'ArrayExpression':
      ast.right = ast.elements;
      ast.right.left = {text: '['};
      ast.right.right = {text: ']'};
      ast.fill = ast.right.fill = [];
      break;

    case 'YieldExpression':
      ast.text = ast.op = 'yield';
    case 'AwaitExpression':
      ast.right = ast.argument;
      ast.text = ast.op = ast.text || ast.op || 'await';
      ast.fill = [];
      break;

    case 'ConditionalExpression':
      left = ast.test;
      operator = '?';
      right = { type: 'Block', list: [ast.consequent, ast.alternate], listSeparator: ':', listStart: '' };
      break;

    case 'MemberExpression':
      left = ast.object;
      operator = ast.computed ? '[]' : '.';
      right = ast.property;
      break;

    case 'IfStatement':
      ast.left = [ast.test];
      ast.left.left = {text: 'if('};
      ast.left.right = {text: ')'};
      ast.left.fill = [];
      ast.right = [ast.consequent];
      ast.right.left = {text: '{'};
      ast.right.right = {text: '}'};
      if(ast.alternate){
        ast.right.push(ast.alternate);
        ast.right.text = '} else {'
      }
      break;

    case 'ForStatement':
      left = { type: 'Block', list: [ast.init, ast.test, ast.update], listSeparator: ';' };
      operator = 'for';
      right = ast.body;
      break;

    case 'WhileStatement':
      left = ast.test;
      operator = 'while';
      right = ast.body;
      break;

    case 'EmptyStatement':
      break;

    default:
      console.warn("Unrecognized node type:", ast.type, ast);
      return ast;
  }
  return ast;
};

// Utility functions
render.fill = function(ast) {
  return (ast.fill instanceof Array && ast.fill) || [Math.random() - 0.2, Math.random() - 0.2, Math.random() - 0.2, 0.3];
};

render.id = function() {
  return Math.random().toString(32).slice(2);
};

render.text = function(ast){
  render.the({
    name: ast.$id + '-text',
    fill: ast.text
  })
}

render.the = function(o) {
  postMessage([o]);
  return render;
};

</script>